<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Retirement Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .card { background: white; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); padding: 24px; margin-bottom: 20px; }
        .input-group label { display: block; font-size: 0.875rem; font-weight: 500; color: #374151; margin-bottom: 4px; }
        .input-group input, .input-group select { width: 100%; padding: 8px 12px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.9rem; }
        .input-group input:focus { outline: none; border-color: #3b82f6; ring: 2px #3b82f6; }
        .input-group input[readonly] { background-color: #f3f4f6; color: #6b7280; cursor: not-allowed; }
        .btn-primary { background-color: #f7931a; color: white; font-weight: 600; padding: 12px 24px; border-radius: 8px; border: none; cursor: pointer; transition: background 0.2s; width: 100%; }
        .btn-primary:hover { background-color: #e68b15; }
        .btn-secondary { background-color: #e5e7eb; color: #374151; font-weight: 600; padding: 8px 12px; border-radius: 6px; border: none; cursor: pointer; font-size: 0.8rem; transition: background 0.2s; }
        .btn-secondary:hover { background-color: #d1d5db; }
        .stat-card { background: #f9fafb; border-radius: 8px; padding: 16px; text-align: center; border: 1px solid #e5e7eb; }
        .stat-value { font-size: 1.5rem; font-weight: 700; color: #111827; }
        .stat-label { font-size: 0.8rem; color: #6b7280; text-transform: uppercase; letter-spacing: 0.05em; }
        table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
        th { background-color: #f3f4f6; padding: 10px; text-align: right; font-weight: 600; color: #374151; position: sticky; top: 0; white-space: nowrap; }
        td { padding: 8px 10px; text-align: right; border-bottom: 1px solid #e5e7eb; }
        tr:last-child td { border-bottom: none; }
        
        /* Scenario Colors */
        .sc-ex-unlucky { color: #7f1d1d; } /* Dark Red */
        .sc-unlucky { color: #dc2626; } /* Red */
        .sc-semi-unlucky { color: #d97706; } /* Orange */
        .sc-median { color: #2563eb; } /* Blue */
        .sc-semi-lucky { color: #7c3aed; } /* Purple */
        .sc-lucky { color: #059669; } /* Green */

        .tab-btn { padding: 8px 16px; cursor: pointer; border-bottom: 2px solid transparent; font-weight: 500; color: #6b7280; }
        .tab-btn.active { color: #f7931a; border-bottom-color: #f7931a; }
        
        .tooltip { position: relative; display: inline-block; cursor: help; margin-left: 4px; color: #9ca3af; }
        .tooltip:hover::after { content: attr(data-tip); position: absolute; left: 50%; bottom: 100%; transform: translateX(-50%); background: #374151; color: white; padding: 6px 10px; border-radius: 4px; font-size: 0.75rem; width: 200px; z-index: 10; margin-bottom: 5px; }
        
        .checkbox-wrapper { display: flex; align-items: center; margin-right: 12px; cursor: pointer; font-size: 0.85rem; user-select: none; }
        .checkbox-wrapper input { margin-right: 6px; accent-color: currentColor; }

        /* Calculator Styles */
        .calc-result-box { border-left: 4px solid #3b82f6; background-color: #eff6ff; padding: 16px; border-radius: 4px; margin-top: 20px; }
        .action-highlight { font-weight: 700; color: #1e40af; font-size: 1.1rem; }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-bold text-gray-900 mb-2">Bitcoin Retirement Simulator</h1>
        <p class="text-gray-600 mb-8">Monte Carlo simulation of volatility harvesting and dynamic withdrawal strategies.</p>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <!-- Left Column: Inputs -->
            <div class="lg:col-span-1 space-y-4">
                
                <!-- Strategy Selection -->
                <div class="card border-l-4 border-orange-500">
                    <h2 class="text-lg font-bold mb-4 text-gray-900">1. Strategy Logic</h2>
                    <div class="input-group">
                        <label>Rebalancing Strategy</label>
                        <select id="strategyType" onchange="updateStrategyDesc(); updateCalculator();">
                            <option value="match_pension">Monthly: Match Pension (Recommended)</option>
                            <option value="skim_1_5">Monthly: Skim 1.5% on Up Months</option>
                            <option value="annual_10">Annual: Sell 10% after Good Year</option>
                            <option value="simple">Simple: No Buffer Refill</option>
                        </select>
                    </div>
                    
                    <!-- Strategy Description Box -->
                    <div id="strategyDescription" class="text-xs text-gray-600 mt-2 p-3 bg-orange-50 rounded border border-orange-100">
                        <!-- JS Populates this -->
                    </div>

                    <div class="input-group mt-3">
                        <label>Withdrawal Rule</label>
                        <select id="withdrawalRule" onchange="updateWithdrawalDesc(); updateCalculator();">
                            <option value="hybrid_floor">Hybrid (Lower of Ideal vs Cap, but > Floor)</option>
                            <option value="strict_cap">Strict Cap (Never exceed % of BTC)</option>
                            <option value="fixed">Fixed Target (Ignore Portfolio Value)</option>
                        </select>
                    </div>

                    <!-- Withdrawal Description Box -->
                    <div id="withdrawalDescription" class="text-xs text-gray-600 mt-2 p-3 bg-blue-50 rounded border border-blue-100">
                        <!-- JS Populates this -->
                    </div>

                    <div class="flex items-center mt-4">
                        <input type="checkbox" id="inflationFreeze" class="w-4 h-4 text-orange-500 rounded" checked onchange="updateCalculator()">
                        <label for="inflationFreeze" class="ml-2 text-sm text-gray-700 font-medium cursor-pointer">
                            Freeze Inflation if Buffer < <span id="freezeLabel">500k</span>
                        </label>
                    </div>
                </div>

                <!-- Accumulation Phase -->
                <div class="card">
                    <h2 class="text-lg font-bold mb-4 text-gray-900">2. Current State (2025)</h2>
                    
                    <!-- BTC API Section -->
                    <div class="bg-gray-50 p-3 rounded mb-4 border border-gray-200">
                        <div class="flex justify-between items-end mb-2">
                            <label class="text-xs font-bold text-gray-500 uppercase">Bitcoin Holdings</label>
                            <button class="btn-secondary text-xs py-1 px-2" onclick="fetchBtcPrice()">
                                ⚡ Fetch Live Price
                            </button>
                        </div>
                        <div class="flex gap-2 mb-2">
                            <input type="number" id="btcAmount" placeholder="Amount (e.g. 2.5)" value="2.5" class="w-full border-gray-300 rounded" oninput="recalcBtcValue()">
                            <span class="flex items-center text-sm font-bold text-gray-600">BTC</span>
                        </div>
                        <div id="priceDisplay" class="text-xs text-gray-500 text-right h-4">
                            <!-- Price will appear here -->
                        </div>
                    </div>

                    <div class="grid grid-cols-2 gap-3">
                        <div class="input-group">
                            <label>Current BTC Value (PLN)</label>
                            <input type="number" id="startBtc" value="1000000" oninput="updateBtcAmountFromValue()"> 
                        </div>
                        <div class="input-group">
                            <label>Current Cash (PLN)</label>
                            <input type="number" id="startCash" value="200000">
                        </div>
                        <div class="input-group">
                            <label>Retirement Year</label>
                            <input type="number" id="retirementYear" value="2030" oninput="updateAccumYears()">
                        </div>
                        <div class="input-group">
                            <label>Accum. Years <span class="tooltip" data-tip="Years between 2025 and Retirement">?</span></label>
                            <input type="number" id="accumYears" value="5" readonly>
                        </div>
                        <div class="input-group col-span-2">
                            <label>Pre-Retirement CAGR</label>
                            <input type="number" id="preCagr" value="0.25" step="0.01">
                        </div>
                    </div>
                </div>

                <!-- Distribution Phase -->
                <div class="card">
                    <h2 class="text-lg font-bold mb-4 text-gray-900">3. Retirement Phase</h2>
                    
                    <h3 class="text-sm font-bold text-gray-500 uppercase tracking-wide mb-2 mt-4">Market Assumptions</h3>
                    <div class="grid grid-cols-2 gap-3">
                        <div class="input-group">
                            <label>Base CAGR (Start)</label>
                            <input type="number" id="baseCagr" value="0.25" step="0.01">
                        </div>
                        <div class="input-group">
                            <label>CAGR Decay <span class="tooltip" data-tip="Multiplies CAGR by this factor annually.">?</span></label>
                            <input type="number" id="decay" value="0.95" step="0.01">
                        </div>
                        <div class="input-group">
                            <label>Base Volatility (Ann.)</label>
                            <input type="number" id="volatility" value="0.60" step="0.05">
                        </div>
                        <div class="input-group">
                            <label>Vol. Decay <span class="tooltip" data-tip="Multiplies Volatility by this factor annually. E.g. 0.9 decreases vol over time.">?</span></label>
                            <input type="number" id="volDecay" value="0.9" step="0.01">
                        </div>
                        <div class="input-group col-span-2">
                            <label>Cash Interest</label>
                            <input type="number" id="cashInterest" value="0.03" step="0.01">
                        </div>
                    </div>

                    <h3 class="text-sm font-bold text-gray-500 uppercase tracking-wide mb-2 mt-4">Pension Goals</h3>
                    <div class="grid grid-cols-2 gap-3">
                        <div class="input-group">
                            <label>Floor Monthly</label>
                            <input type="number" id="floorPension" value="10000" oninput="updateCalculator()">
                        </div>
                        <div class="input-group">
                            <label>Ideal Monthly</label>
                            <input type="number" id="idealPension" value="15000" oninput="updateCalculator()">
                        </div>
                        <div class="input-group">
                            <label>Yearly Inflation</label>
                            <input type="number" id="pensionGrowth" value="0.05" step="0.01" oninput="updateCalculator()">
                        </div>
                        <div class="input-group">
                            <label>Safe Cap % (Monthly)</label>
                            <input type="number" id="safeCapPct" value="0.005" step="0.001" oninput="updateCalculator()">
                        </div>
                    </div>
                    
                    <div class="input-group mt-3">
                        <label>Freeze Threshold (PLN)</label>
                        <input type="number" id="freezeThreshold" value="500000">
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-3">
                    <div class="input-group">
                        <label>Duration (Years)</label>
                        <input type="number" id="simYears" value="10">
                    </div>
                    <div class="input-group">
                        <label>Num. Simulations</label>
                        <input type="number" id="nSims" value="1000" step="1000" max="100000">
                    </div>
                </div>

                <button class="btn-primary mt-4" onclick="runSimulation()">Run Simulation</button>
            </div>

            <!-- Right Column: Results -->
            <div class="lg:col-span-2">
                
                <!-- KPI Cards -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                    <div class="stat-card">
                        <div class="stat-value text-green-600" id="statSurvival">--%</div>
                        <div class="stat-label">Survival Rate</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value text-blue-600" id="statMedianWealth">--x</div>
                        <div class="stat-label">Median Wealth Mult.</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value text-orange-600" id="statFloorHit">--%</div>
                        <div class="stat-label">Floor Pension Freq.</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value text-gray-600" id="statUnluckyWealth">--</div>
                        <div class="stat-label">Unlucky Outcome (PLN)</div>
                    </div>
                </div>

                <!-- Charts -->
                <div class="card">
                    <div class="flex items-center justify-between border-b border-gray-200 mb-4">
                        <div class="flex">
                            <div class="tab-btn active" onclick="switchTab('wealth')">Total Capital</div>
                            <div class="tab-btn" onclick="switchTab('pension')">Monthly Pension</div>
                            <div class="tab-btn" onclick="switchTab('buffer')">Cash Buffer</div>
                        </div>
                    </div>
                    
                    <!-- Chart Visibility Controls -->
                    <div class="flex flex-wrap gap-2 mb-3 justify-center text-xs">
                        <label class="checkbox-wrapper sc-ex-unlucky font-bold"><input type="checkbox" id="chartShowExUnlucky" onchange="updateChartVisibility()" checked> Extreme (5%)</label>
                        <label class="checkbox-wrapper sc-unlucky font-bold"><input type="checkbox" id="chartShowUnlucky" onchange="updateChartVisibility()" checked> Unlucky (10%)</label>
                        <label class="checkbox-wrapper sc-semi-unlucky font-bold"><input type="checkbox" id="chartShowSemiUnlucky" onchange="updateChartVisibility()"> Semi-Un (30%)</label>
                        <label class="checkbox-wrapper sc-median font-bold"><input type="checkbox" id="chartShowMedian" onchange="updateChartVisibility()" checked> Median (50%)</label>
                        <label class="checkbox-wrapper sc-semi-lucky font-bold"><input type="checkbox" id="chartShowSemiLucky" onchange="updateChartVisibility()"> Semi-Lu (70%)</label>
                        <label class="checkbox-wrapper sc-lucky font-bold"><input type="checkbox" id="chartShowLucky" onchange="updateChartVisibility()" checked> Lucky (90%)</label>
                    </div>

                    <div style="height: 300px;">
                        <canvas id="mainChart"></canvas>
                    </div>
                </div>

                <!-- Detailed Table -->
                <div class="card overflow-x-auto">
                    <h3 class="text-lg font-bold mb-2 text-gray-900">Yearly Breakdown</h3>
                    
                    <!-- Table Toggle Controls -->
                    <div class="flex flex-wrap gap-2 mb-4 bg-gray-50 p-3 rounded-lg border border-gray-200">
                        <label class="checkbox-wrapper sc-ex-unlucky font-semibold">
                            <input type="checkbox" id="showExUnlucky" onchange="renderTable()"> Extreme (5%)
                        </label>
                        <label class="checkbox-wrapper sc-unlucky font-semibold">
                            <input type="checkbox" id="showUnlucky" onchange="renderTable()" checked> Unlucky (10%)
                        </label>
                        <label class="checkbox-wrapper sc-semi-unlucky font-semibold">
                            <input type="checkbox" id="showSemiUnlucky" onchange="renderTable()"> Semi-Unlucky (30%)
                        </label>
                        <label class="checkbox-wrapper sc-median font-semibold">
                            <input type="checkbox" id="showMedian" onchange="renderTable()" checked> Median (50%)
                        </label>
                        <label class="checkbox-wrapper sc-semi-lucky font-semibold">
                            <input type="checkbox" id="showSemiLucky" onchange="renderTable()"> Semi-Lucky (70%)
                        </label>
                        <label class="checkbox-wrapper sc-lucky font-semibold">
                            <input type="checkbox" id="showLucky" onchange="renderTable()"> Lucky (90%)
                        </label>
                    </div>

                    <table id="resultsTable">
                        <thead>
                            <!-- Header Generated by JS -->
                        </thead>
                        <tbody>
                            <!-- JS Populates this -->
                        </tbody>
                    </table>
                </div>

                <!-- ACTION CALCULATOR -->
                <div class="card border border-blue-200 bg-white">
                    <h2 class="text-xl font-bold text-gray-800 mb-4 flex items-center">
                        <span class="bg-blue-600 text-white rounded-full w-8 h-8 flex items-center justify-center mr-3 text-sm">Now</span>
                        Monthly Action Calculator
                    </h2>
                    <p class="text-sm text-gray-500 mb-4">Enter your current real-time stats to get a specific instruction based on the chosen strategy.</p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                        <div class="input-group">
                            <label>Current Year</label>
                            <input type="number" id="calcYear" value="2030" oninput="updateCalculator()">
                        </div>
                        <div class="input-group">
                            <label>Current BTC Value (PLN)</label>
                            <input type="number" id="calcBtc" value="2500000" oninput="updateCalculator()">
                        </div>
                        <div class="input-group">
                            <label>Current Buffer (PLN)</label>
                            <input type="number" id="calcBuffer" value="250000" oninput="updateCalculator()">
                        </div>
                        <div class="input-group">
                            <label>BTC Return This Month (%)</label>
                            <input type="number" id="calcReturn" value="5.0" step="0.1" oninput="updateCalculator()">
                        </div>
                    </div>
                    
                    <button class="btn-primary mb-4 bg-blue-600 hover:bg-blue-700" onclick="updateCalculator()">Calculate Action</button>

                    <div id="calcResult" class="calc-result-box hidden">
                        <!-- Result populated by JS -->
                    </div>
                </div>

            </div>
        </div>
    </div>

<script>
    // --- Global State ---
    let chartInstance = null;
    let globalSimResults = null; 
    let globalInputs = null;
    let currentBtcPricePln = 0; // Store fetched price

    // --- API Logic ---
    async function fetchBtcPrice() {
        const display = document.getElementById('priceDisplay');
        display.innerHTML = '<span class="text-blue-500">Fetching...</span>';
        
        try {
            const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=pln,usd');
            const data = await response.json();
            
            if (data.bitcoin) {
                const pln = data.bitcoin.pln;
                const usd = data.bitcoin.usd;
                currentBtcPricePln = pln;
                
                const fmt = (n, curr) => new Intl.NumberFormat('en-US', { style: 'currency', currency: curr }).format(n);
                display.innerHTML = `1 BTC = <strong>${fmt(pln, 'PLN')}</strong> / ${fmt(usd, 'USD')}`;
                
                // Auto-update Start Value if BTC Amount is present
                recalcBtcValue();
            } else {
                display.innerHTML = '<span class="text-red-500">Error fetching price.</span>';
            }
        } catch (e) {
            console.error(e);
            display.innerHTML = '<span class="text-red-500">API Error. Try again later.</span>';
        }
    }

    function recalcBtcValue() {
        if (currentBtcPricePln > 0) {
            const amount = parseFloat(document.getElementById('btcAmount').value) || 0;
            const val = Math.round(amount * currentBtcPricePln);
            document.getElementById('startBtc').value = val;
        }
    }

    function updateBtcAmountFromValue() {
        if (currentBtcPricePln > 0) {
            const val = parseFloat(document.getElementById('startBtc').value) || 0;
            const amt = val / currentBtcPricePln;
            document.getElementById('btcAmount').value = amt.toFixed(4);
        }
    }

    function updateAccumYears() {
        const retirement = parseInt(document.getElementById('retirementYear').value) || 2030;
        const current = 2025; // Base current year
        const accum = Math.max(0, retirement - current);
        document.getElementById('accumYears').value = accum;
        
        // Also update calcYear default for convenience if user changes retirement target
        document.getElementById('calcYear').value = retirement;
        updateCalculator();
    }

    // --- Strategy Descriptions ---
    const strategyInfo = {
        'match_pension': {
            desc: "<strong>Logic:</strong> On positive months, sell 2x pension amount (1x for living, 1x to buffer). On negative months, pay from buffer.",
            ex: "<strong>Example:</strong> Pension 10k. BTC Up? Sell 20k BTC (10k pocket, 10k buffer). BTC Down? Sell 0 BTC, take 10k from Buffer."
        },
        'skim_1_5': {
            desc: "<strong>Logic:</strong> On positive months, sell pension amount + 1.5% of total Bitcoin holdings to buffer. On negative months, pay from buffer.",
            ex: "<strong>Example:</strong> Portfolio 1M. Pension 10k. BTC Up? Sell 10k (pension) + 15k (1.5% skim) to Buffer."
        },
        'annual_10': {
            desc: "<strong>Logic:</strong> Once a year (Jan), if previous year was positive, sell 10% of Bitcoin holdings to buffer. Monthly payments come from Buffer if BTC is down.",
            ex: "<strong>Example:</strong> Jan 1st, BTC holding 1M. Last year up? Sell 100k to Buffer."
        },
        'simple': {
            desc: "<strong>Logic:</strong> Standard withdrawal. Pay from Buffer only when Bitcoin drops to avoid selling low. No proactive profit taking.",
            ex: "<strong>Example:</strong> BTC Down? Use cash. BTC Up? Sell BTC for pension."
        }
    };

    const withdrawalInfo = {
        'hybrid_floor': {
            desc: "<strong>Logic:</strong> Flexible withdrawal. Calculate Safe Cap (0.5% of BTC). If Cap is between Floor and Ideal, take Cap. If Cap > Ideal, take Ideal (save remainder). If Cap < Floor, take Floor (subsidized by Buffer).",
            ex: "<strong>Example:</strong> Floor 10k, Ideal 15k. <br>• Cap = 8k? Take 10k (Buffer covers 2k).<br>• Cap = 12k? Take 12k.<br>• Cap = 20k? Take 15k."
        },
        'strict_cap': {
            desc: "<strong>Logic:</strong> Rigid safety. Always take exactly the Safe Cap % (e.g. 0.5% of BTC). No floor protection.",
            ex: "<strong>Example:</strong> BTC drops to 1M? Pension is 5k. BTC rises to 4M? Pension is 20k. Income fluctuates wildly."
        },
        'fixed': {
            desc: "<strong>Logic:</strong> Rigid lifestyle. Always take the Ideal Pension amount adjusted for inflation, regardless of portfolio performance.",
            ex: "<strong>Example:</strong> Ideal 15k. BTC crashes? Still take 15k. High risk of depleting capital early."
        }
    };

    function updateStrategyDesc() {
        const val = document.getElementById('strategyType').value;
        const info = strategyInfo[val];
        document.getElementById('strategyDescription').innerHTML = `${info.desc}<br><div class="mt-1 text-gray-500">${info.ex}</div>`;
    }

    function updateWithdrawalDesc() {
        const val = document.getElementById('withdrawalRule').value;
        const info = withdrawalInfo[val];
        document.getElementById('withdrawalDescription').innerHTML = `${info.desc}<br><div class="mt-1 text-gray-500">${info.ex}</div>`;
    }

    // --- Action Calculator Logic ---
    function updateCalculator() {
        const currentYear = parseFloat(document.getElementById('calcYear').value);
        const currentBtc = parseFloat(document.getElementById('calcBtc').value);
        const currentBuffer = parseFloat(document.getElementById('calcBuffer').value);
        const monthlyReturn = parseFloat(document.getElementById('calcReturn').value);
        
        const strategy = document.getElementById('strategyType').value;
        const withdrawalRule = document.getElementById('withdrawalRule').value;
        
        // Goals (Inflation Adjusted)
        const retirementYear = parseFloat(document.getElementById('retirementYear').value) || 2030;
        const startYear = retirementYear;
        const yearsPassed = Math.max(0, currentYear - startYear);
        
        const growthRate = parseFloat(document.getElementById('pensionGrowth').value);
        const baseFloor = parseFloat(document.getElementById('floorPension').value);
        const baseIdeal = parseFloat(document.getElementById('idealPension').value);
        
        // Simple inflation adjustment (ignores freeze history for this instant calculator, assumes standard path)
        const inflationFactor = Math.pow(1 + growthRate, yearsPassed);
        const targetFloor = baseFloor * inflationFactor;
        const targetIdeal = baseIdeal * inflationFactor;
        
        // Calculate Pension
        const wRatePct = parseFloat(document.getElementById('safeCapPct').value);
        const safeCap = currentBtc * wRatePct;
        
        let actualPension = 0;
        if (withdrawalRule === 'fixed') {
            actualPension = targetIdeal;
        } else if (withdrawalRule === 'strict_cap') {
            actualPension = safeCap;
        } else { // Hybrid
            actualPension = Math.max(targetFloor, Math.min(targetIdeal, safeCap));
        }
        
        // Strategy Logic
        const isPositive = monthlyReturn > 0;
        let sellBtc = 0;
        let drainBuffer = 0;
        let addToBuffer = 0;
        let message = "";
        
        if (strategy === 'match_pension') {
            if (isPositive) {
                // Sell 2x Pension (1 to pocket, 1 to buffer)
                sellBtc = actualPension * 2;
                addToBuffer = actualPension;
                message = `Bitcoin is UP. Sell 2x Pension amount. Use half for living, put half in buffer.`;
            } else {
                // Drain Buffer
                if (currentBuffer >= actualPension) {
                    drainBuffer = actualPension;
                    message = `Bitcoin is DOWN/FLAT. Preserve Bitcoin. Pay pension entirely from Buffer.`;
                } else {
                    drainBuffer = currentBuffer;
                    sellBtc = actualPension - currentBuffer;
                    message = `Bitcoin is DOWN. Buffer is insufficient! Drain remaining buffer (${Math.round(drainBuffer)}) and sell Bitcoin for the rest.`;
                }
            }
        } else if (strategy === 'skim_1_5') {
            if (isPositive) {
                // Sell Pension + 1.5% Skim
                const skim = currentBtc * 0.015;
                sellBtc = actualPension + skim;
                addToBuffer = skim;
                message = `Bitcoin is UP. Pay pension from BTC profits AND skim 1.5% (${Math.round(skim).toLocaleString()} PLN) into buffer.`;
            } else {
                // Drain Buffer
                if (currentBuffer >= actualPension) {
                    drainBuffer = actualPension;
                    message = `Bitcoin is DOWN/FLAT. Preserve Bitcoin. Pay pension entirely from Buffer.`;
                } else {
                    drainBuffer = currentBuffer;
                    sellBtc = actualPension - currentBuffer;
                    message = `Bitcoin is DOWN. Buffer insufficient. Drain buffer and sell remainder from BTC.`;
                }
            }
        } else {
            // Simple/Annual (Monthly logic default)
            // Just pay pension. If positive, from BTC. If negative, from Buffer (Standard safe withdrawal)
            if (isPositive) {
                sellBtc = actualPension;
                message = `Bitcoin is UP. Sell Bitcoin to pay pension.`;
            } else {
                if (currentBuffer >= actualPension) {
                    drainBuffer = actualPension;
                    message = `Bitcoin is DOWN. Pay from Buffer.`;
                } else {
                    drainBuffer = currentBuffer;
                    sellBtc = actualPension - currentBuffer;
                    message = `Bitcoin is DOWN. Drain Buffer, pay rest from BTC.`;
                }
            }
        }
        
        // Formatting
        const fmt = (n) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'PLN', maximumFractionDigits: 0 }).format(n);
        
        const resultHTML = `
            <div class="mb-4">
                <div class="text-sm font-bold text-gray-500 uppercase">Calculated Pension Target</div>
                <div class="text-2xl font-bold text-gray-900">${fmt(actualPension)}</div>
                <div class="text-xs text-gray-500">Based on Floor ${fmt(targetFloor)} / Ideal ${fmt(targetIdeal)}</div>
            </div>
            
            <div class="p-3 bg-white border border-blue-200 rounded mb-3">
                <div class="text-sm font-bold text-blue-800 mb-1">INSTRUCTION:</div>
                <div class="text-gray-800 text-sm mb-2">${message}</div>
                <ul class="list-disc list-inside text-sm text-gray-700">
                    <li><strong>Sell Bitcoin:</strong> ${fmt(sellBtc)}</li>
                    <li><strong>Withdraw from Buffer:</strong> ${fmt(drainBuffer)}</li>
                    <li><strong>Add to Buffer:</strong> ${fmt(addToBuffer)}</li>
                    <li><strong>Net to Pocket:</strong> ${fmt(actualPension)}</li>
                </ul>
            </div>
            
            <div class="grid grid-cols-2 gap-4 text-sm bg-gray-50 p-2 rounded">
                <div>
                    <span class="block text-gray-500">New BTC Balance</span>
                    <span class="font-bold">${fmt(currentBtc - sellBtc)}</span>
                </div>
                <div>
                    <span class="block text-gray-500">New Cash Buffer</span>
                    <span class="font-bold">${fmt(currentBuffer - drainBuffer + addToBuffer)}</span>
                </div>
            </div>
        `;
        
        const resBox = document.getElementById('calcResult');
        resBox.innerHTML = resultHTML;
        resBox.classList.remove('hidden');
    }

    // --- Simulation Engine ---
    function runSimulation() {
        // 1. Gather Inputs
        const nSimsEl = document.getElementById('nSims');
        const nSimsInput = nSimsEl ? parseInt(nSimsEl.value) : 1000;
        const nSims = isNaN(nSimsInput) ? 1000 : nSimsInput;

        // Auto-update Accum Years just in case
        updateAccumYears();

        const inputs = {
            btcInitial: parseFloat(document.getElementById('startBtc').value),
            cashInitial: parseFloat(document.getElementById('startCash').value),
            accumYears: parseFloat(document.getElementById('accumYears').value),
            retirementYear: parseFloat(document.getElementById('retirementYear').value),
            preCagr: parseFloat(document.getElementById('preCagr').value),
            
            baseCagr: parseFloat(document.getElementById('baseCagr').value),
            decay: parseFloat(document.getElementById('decay').value),
            vol: parseFloat(document.getElementById('volatility').value),
            volDecay: parseFloat(document.getElementById('volDecay').value),
            cashInterest: parseFloat(document.getElementById('cashInterest').value),
            
            floorBase: parseFloat(document.getElementById('floorPension').value),
            idealBase: parseFloat(document.getElementById('idealPension').value),
            pensionGrowth: parseFloat(document.getElementById('pensionGrowth').value),
            wRatePct: parseFloat(document.getElementById('safeCapPct').value),
            
            simYears: parseInt(document.getElementById('simYears').value),
            freezeThreshold: parseFloat(document.getElementById('freezeThreshold').value),
            useFreeze: document.getElementById('inflationFreeze').checked,
            
            strategy: document.getElementById('strategyType').value,
            rule: document.getElementById('withdrawalRule').value
        };
        globalInputs = inputs;

        const totalMonths = inputs.simYears * 12;
        const dt = 1/12;
        
        // Calculate Start Values based on accumYears
        // (inputs.accumYears should be auto-updated by updateAccumYears before this)
        const btcStart = inputs.btcInitial * Math.pow(1 + inputs.preCagr, inputs.accumYears);
        const cashStart = inputs.cashInitial * Math.pow(1 + 0.03, inputs.accumYears); 

        // Arrays for tracking
        let simBtc = new Float64Array(nSims).fill(btcStart);
        let simCash = new Float64Array(nSims).fill(cashStart);
        
        // History arrays for charting 
        let historyWealth = []; 
        let historyPension = []; 
        let historyBuffer = [];
        
        // **NEW: Yearly Stats for Table**
        // We will store stats for each year (Unlucky, Semi, Median, etc.)
        let yearlyTableData = [];

        // Track Hits
        let floorHits = 0;
        let idealHits = 0;
        let monthsCounted = 0;

        // Current Pension Targets per Sim
        let currentFloors = new Float64Array(nSims).fill(inputs.floorBase);
        let currentIdeals = new Float64Array(nSims).fill(inputs.idealBase);

        const monthlyInterest = Math.pow(1 + inputs.cashInterest, 1/12);
        
        // Temp array for sorting pensions per month for chart percentiles
        let currentMonthPensions = new Float64Array(nSims);
        
        // Accumulator for yearly average pension (sim-specific)
        let yearlyPensionAccum = new Float64Array(nSims).fill(0);

        // Simulation Loop
        for (let m = 0; m < totalMonths; m++) {
            const yearIdx = Math.floor(m / 12);
            const isJan = (m % 12) === 0;

            // --- A. Annual Updates (Inflation / Freeze) ---
            if (isJan && yearIdx > 0) {
                // Reset yearly accumulator at start of year
                yearlyPensionAccum.fill(0);
                
                for (let i = 0; i < nSims; i++) {
                    let grow = 1.0 + inputs.pensionGrowth;
                    if (inputs.useFreeze && simCash[i] < inputs.freezeThreshold) {
                        grow = 1.0;
                    }
                    currentFloors[i] *= grow;
                    currentIdeals[i] *= grow;
                }
            }

            // --- B. Growth ---
            const currentCagr = inputs.baseCagr * Math.pow(inputs.decay, yearIdx);
            const currentVol = inputs.vol * Math.pow(inputs.volDecay, yearIdx);
            
            const drift = Math.log(1 + currentCagr);
            const volTerm = currentVol * Math.sqrt(dt);
            
            for (let i = 0; i < nSims; i++) {
                let u1 = Math.random();
                let u2 = Math.random();
                let z = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
                
                let growthFactor = Math.exp((drift * dt) + (volTerm * z));
                
                let oldBtc = simBtc[i];
                simBtc[i] *= growthFactor;
                simCash[i] *= monthlyInterest;
                
                // --- C. Logic ---
                let isPositive = simBtc[i] > oldBtc; 
                
                // Determine Withdrawal
                let targetPension = 0;
                let cap = simBtc[i] * inputs.wRatePct;
                
                if (inputs.rule === 'fixed') {
                    targetPension = currentIdeals[i];
                } else if (inputs.rule === 'strict_cap') {
                    targetPension = cap;
                } else { // Hybrid
                    targetPension = Math.max(currentFloors[i], Math.min(currentIdeals[i], cap));
                }
                
                if (targetPension === currentFloors[i]) floorHits++;
                if (targetPension === currentIdeals[i]) idealHits++;
                
                // Payment Execution
                let paidFromCash = 0;
                let paidFromBtc = 0;
                let skimAmount = 0;
                
                if (inputs.strategy === 'match_pension') {
                    if (isPositive) {
                        paidFromBtc = targetPension;
                        skimAmount = targetPension; 
                    } else {
                        if (simCash[i] >= targetPension) {
                            paidFromCash = targetPension;
                        } else {
                            paidFromCash = simCash[i];
                            paidFromBtc = targetPension - simCash[i]; 
                        }
                    }
                } else if (inputs.strategy === 'skim_1_5') {
                    if (isPositive) {
                        paidFromBtc = targetPension;
                        skimAmount = simBtc[i] * 0.015;
                    } else {
                        if (simCash[i] >= targetPension) {
                            paidFromCash = targetPension;
                        } else {
                            paidFromCash = simCash[i];
                            paidFromBtc = targetPension - simCash[i];
                        }
                    }
                } else {
                    if (simCash[i] >= targetPension) {
                        paidFromCash = targetPension;
                    } else {
                        paidFromCash = simCash[i];
                        paidFromBtc = targetPension - simCash[i];
                    }
                }
                
                simCash[i] -= paidFromCash;
                simCash[i] += skimAmount;
                
                simBtc[i] -= (paidFromBtc + skimAmount);
                
                if (simBtc[i] < 0) {
                    simCash[i] += simBtc[i]; 
                    simBtc[i] = 0;
                }
                
                currentMonthPensions[i] = targetPension;
                yearlyPensionAccum[i] += targetPension;
            }
            
            monthsCounted += nSims;

            // Store snapshots for charts
            if (m % 3 === 0 || m === totalMonths - 1) { 
                 // ... Chart snapshot logic same as before ...
                 let wealths = new Float64Array(nSims);
                 for(let k=0; k<nSims; k++) wealths[k] = simBtc[k] + simCash[k];
                 wealths.sort();
                 
                 historyWealth.push({ m: m, p05: wealths[Math.floor(nSims * 0.05)], p10: wealths[Math.floor(nSims * 0.1)], p30: wealths[Math.floor(nSims * 0.3)], p50: wealths[Math.floor(nSims * 0.5)], p70: wealths[Math.floor(nSims * 0.7)], p90: wealths[Math.floor(nSims * 0.9)] });
                 
                 let cashes = new Float64Array(simCash);
                 cashes.sort();
                 historyBuffer.push({ m: m, p05: cashes[Math.floor(nSims * 0.05)], p10: cashes[Math.floor(nSims * 0.1)], p30: cashes[Math.floor(nSims * 0.3)], p50: cashes[Math.floor(nSims * 0.5)], p70: cashes[Math.floor(nSims * 0.7)], p90: cashes[Math.floor(nSims * 0.9)] });

                 let sortedPensions = new Float64Array(currentMonthPensions);
                 sortedPensions.sort();
                 historyPension.push({ m: m, p05: sortedPensions[Math.floor(nSims * 0.05)], p10: sortedPensions[Math.floor(nSims * 0.1)], p30: sortedPensions[Math.floor(nSims * 0.3)], p50: sortedPensions[Math.floor(nSims * 0.5)], p70: sortedPensions[Math.floor(nSims * 0.7)], p90: sortedPensions[Math.floor(nSims * 0.9)] });
            }
            
            // **Capture Yearly Stats for Table** (At Month 11, 23, 35...)
            if (m % 12 === 11) {
                let yearSnapshots = [];
                for(let k=0; k<nSims; k++) {
                    yearSnapshots.push({
                        w: simBtc[k] + simCash[k],
                        b: simCash[k],
                        p: yearlyPensionAccum[k] / 12.0
                    });
                }
                yearSnapshots.sort((a, b) => a.w - b.w);
                
                yearlyTableData.push({
                    year: inputs.retirementYear + yearIdx,
                    exUnlucky: yearSnapshots[Math.floor(nSims * 0.05)],
                    unlucky: yearSnapshots[Math.floor(nSims * 0.10)],
                    semiUnlucky: yearSnapshots[Math.floor(nSims * 0.30)],
                    median: yearSnapshots[Math.floor(nSims * 0.50)],
                    semiLucky: yearSnapshots[Math.floor(nSims * 0.70)],
                    lucky: yearSnapshots[Math.floor(nSims * 0.90)]
                });
            }
        }

        // --- 4. Final Analysis Data Structure ---
        let finalState = [];
        for(let i=0; i<nSims; i++) {
            finalState.push({ val: simBtc[i] + simCash[i] });
        }
        finalState.sort((a, b) => a.val - b.val);
        const survivalRate = finalState.filter(w => w.val > 1000).length / nSims;
        const medianMult = finalState[Math.floor(nSims * 0.5)].val / (btcStart + cashStart);
        
        globalTableData = yearlyTableData;

        document.getElementById('statSurvival').innerText = (survivalRate * 100).toFixed(1) + "%";
        document.getElementById('statMedianWealth').innerText = medianMult.toFixed(2) + "x";
        document.getElementById('statFloorHit').innerText = ((floorHits / monthsCounted) * 100).toFixed(1) + "%";
        const unluckyFmt = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'PLN', maximumFractionDigits: 0 }).format(finalState[Math.floor(nSims * 0.1)].val);
        document.getElementById('statUnluckyWealth').innerText = unluckyFmt;

        renderTable();
        updateChart(historyWealth, historyPension, historyBuffer);
        updateCalculator();
    }

    function renderTable() {
        if (!globalTableData || !globalInputs) return;

        const tableHead = document.querySelector('#resultsTable thead');
        const tableBody = document.querySelector('#resultsTable tbody');
        
        const scenarios = [
            { key: 'exUnlucky', label: 'Extreme (5%)', cls: 'sc-ex-unlucky', show: document.getElementById('showExUnlucky').checked },
            { key: 'unlucky', label: 'Unlucky (10%)', cls: 'sc-unlucky', show: document.getElementById('showUnlucky').checked },
            { key: 'semiUnlucky', label: 'Semi (30%)', cls: 'sc-semi-unlucky', show: document.getElementById('showSemiUnlucky').checked },
            { key: 'median', label: 'Median (50%)', cls: 'sc-median', show: document.getElementById('showMedian').checked },
            { key: 'semiLucky', label: 'Semi (70%)', cls: 'sc-semi-lucky', show: document.getElementById('showSemiLucky').checked },
            { key: 'lucky', label: 'Lucky (90%)', cls: 'sc-lucky', show: document.getElementById('showLucky').checked }
        ];

        let headerHTML = '<tr><th class="text-left">Year</th><th>Target Range</th>';
        scenarios.forEach(s => {
            if (s.show) {
                headerHTML += `<th class="${s.cls}">${s.label} Pension</th>`;
                headerHTML += `<th class="${s.cls}">${s.label} Buffer</th>`;
                headerHTML += `<th class="${s.cls}">${s.label} Wealth</th>`;
            }
        });
        headerHTML += '</tr>';
        tableHead.innerHTML = headerHTML;

        tableBody.innerHTML = '';
        const growth = globalInputs.pensionGrowth;
        const baseFloor = globalInputs.floorBase;
        const baseIdeal = globalInputs.idealBase;
        const fmt = (n) => new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 }).format(n);

        // Iterate through stored yearly data
        globalTableData.forEach(row => {
            const y = row.year;
            const offset = y - globalInputs.retirementYear;
            
            // Standard Targets (nominal)
            const f = baseFloor * Math.pow(1+growth, offset);
            const i = baseIdeal * Math.pow(1+growth, offset);
            
            let rowHTML = `<tr><td class="text-left font-bold">${y}</td><td class="text-gray-500 text-xs">${fmt(f)} - ${fmt(i)}</td>`;

            scenarios.forEach(s => {
                if (s.show) {
                    const data = row[s.key];
                    // USE REAL DATA
                    rowHTML += `<td class="${s.cls}">${fmt(data.p)}</td>`;
                    rowHTML += `<td class="${s.cls}">${fmt(data.b)}</td>`;
                    rowHTML += `<td class="${s.cls} font-bold">${fmt(data.w)}</td>`;
                }
            });
            rowHTML += '</tr>';
            tableBody.innerHTML += rowHTML;
        });
    }

    // New function to handle chart visibility based on checkboxes
    function updateChartVisibility() {
        if (!window.currentChartData || !chartInstance) return;
        
        const visibility = {
            'Lucky (90%)': document.getElementById('chartShowLucky').checked,
            'Semi-Lucky (70%)': document.getElementById('chartShowSemiLucky').checked,
            'Median (50%)': document.getElementById('chartShowMedian').checked,
            'Semi-Unlucky (30%)': document.getElementById('chartShowSemiUnlucky').checked,
            'Unlucky (10%)': document.getElementById('chartShowUnlucky').checked,
            'Extreme (5%)': document.getElementById('chartShowExUnlucky').checked
        };

        chartInstance.data.datasets.forEach(ds => {
            ds.hidden = !visibility[ds.label];
        });
        chartInstance.update();
    }

    function updateChart(wealthData, pensionData, bufferData) {
        const ctx = document.getElementById('mainChart').getContext('2d');
        
        if (chartInstance) chartInstance.destroy();

        const labels = wealthData.map(d => {
            const date = new Date(globalInputs.retirementYear, 0, 1);
            date.setMonth(d.m);
            return date.getFullYear();
        });

        // Initialize empty, populated by switchTab logic
        // But to support initial load, we must populate
        // Let's populate Wealth data by default
        
        const d = wealthData;

        chartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    { label: 'Lucky (90%)', borderColor: '#059669', borderWidth: 2, pointRadius: 0, fill: false, data: d.map(x=>x.p90) },
                    { label: 'Semi-Lucky (70%)', borderColor: '#7c3aed', borderWidth: 2, pointRadius: 0, fill: false, data: d.map(x=>x.p70) },
                    { label: 'Median (50%)', borderColor: '#2563eb', borderWidth: 3, pointRadius: 0, fill: false, data: d.map(x=>x.p50) },
                    { label: 'Semi-Unlucky (30%)', borderColor: '#d97706', borderWidth: 2, pointRadius: 0, fill: false, data: d.map(x=>x.p30) },
                    { label: 'Unlucky (10%)', borderColor: '#dc2626', borderWidth: 2, pointRadius: 0, borderDash: [5, 5], fill: false, data: d.map(x=>x.p10) },
                    { label: 'Extreme (5%)', borderColor: '#7f1d1d', borderWidth: 1, pointRadius: 0, borderDash: [2, 2], fill: false, data: d.map(x=>x.p05) }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + new Intl.NumberFormat('en-US', { style: 'currency', currency: 'PLN', maximumFractionDigits: 0 }).format(context.raw);
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
                                if (value >= 1000) return (value / 1000).toFixed(0) + 'k';
                                return value;
                            }
                        }
                    }
                }
            }
        });
        
        window.currentChartData = { wealth: wealthData, pension: pensionData, buffer: bufferData, labels: labels };
        
        // Apply initial visibility from checkboxes
        updateChartVisibility();
    }

    function switchTab(type) {
        if (!window.currentChartData || !chartInstance) return;
        
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        event.target.classList.add('active');

        const d = window.currentChartData;
        let source;

        if (type === 'wealth') source = d.wealth;
        else if (type === 'buffer') source = d.buffer;
        else source = d.pension;

        // Map data to datasets
        // Order: Lucky, SemiLucky, Median, SemiUnlucky, Unlucky, Extreme
        const keys = ['p90', 'p70', 'p50', 'p30', 'p10', 'p05'];
        
        chartInstance.data.datasets.forEach((ds, i) => {
            ds.data = source.map(x => x[keys[i]]);
        });
        
        // Update Y Axis Format
        if (type === 'pension') {
             chartInstance.options.scales.y.ticks.callback = (v) => (v/1000).toFixed(0) + 'k';
        } else {
             chartInstance.options.scales.y.ticks.callback = (v) => {
                 if (v >= 1000000) return (v / 1000000).toFixed(1) + 'M';
                 if (v >= 1000) return (v / 1000).toFixed(0) + 'k';
                 return v;
             };
        }

        chartInstance.update();
    }

    document.getElementById('freezeThreshold').addEventListener('input', (e) => {
        document.getElementById('freezeLabel').innerText = (e.target.value / 1000) + 'k';
    });

    // Initialize Desc
    updateStrategyDesc();
    updateWithdrawalDesc();
    
    // Initial Run
    runSimulation();

</script>
</body>
</html>
